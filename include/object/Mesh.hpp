#pragma once
#ifndef _MESH_HPP_
#define _MESH_HPP_
#define GLM_ENABLE_EXPERIMENTAL // Enable experimental features
#include <bvh/Bounds3.hpp>
#include <functional> // For std::hash
#include <glm/glm.hpp>
#include <glm/gtx/hash.hpp>
#include <memory>
#include <object/Material.hpp>
#include <object/Object.hpp>
#include <string>
#include <tbb/concurrent_vector.h>
#include <bvh/BVHAcceleration.hpp>

namespace SoftRasterizer {

/*forward declaration*/
class Shader;

struct Vertex {
  glm::vec3 position;
  glm::vec3 normal;
  glm::vec2 texCoord;
  glm::vec3 color = glm::vec3(1.0f);

  bool operator==(const Vertex &other) const {
    return this->position == other.position && this->color == other.color &&
           this->normal == other.normal && this->texCoord == other.texCoord;
  }
};

struct Mesh : public Object {
public:
  Mesh();
  Mesh(const std::string &name);
  Mesh(const std::string &name, const SoftRasterizer::Material &_material,
       const std::vector<Vertex> &_vertices,
       const std::vector<glm::uvec3> &_faces, const Bounds3 &box);

  Mesh(const std::string &name, SoftRasterizer::Material &&_material,
       std::vector<Vertex> &&_vertices, std::vector<glm::uvec3> &&_faces,
       Bounds3 &&box);

  virtual ~Mesh();
  void bindShader2Mesh(std::shared_ptr<Shader> shader);

public:
  void updateBounds(const Bounds3 &new_box) { bounding_box = new_box; }
  Bounds3 getBounds() override { return bounding_box; }
  [[nodiscard]] bool intersect(const Ray &ray) override;
  [[nodiscard]] bool intersect(const Ray &ray, float &tNear) override;
  [[nodiscard]] Intersection getIntersect(Ray &ray) override;
  [[nodiscard]] Properties getSurfaceProperties(const std::size_t faceIndex, const glm::vec3& Point, const glm::vec3& viewDir, const glm::vec2& uv)override;
  [[nodiscard]] std::shared_ptr<Material> getMaterial() override;
  [[nodiscard]] glm::vec3 getDiffuseColor(const glm::vec2& uv) override;

  /*Rebuild BVH Structure, When Points position moved!*/
  void rebuildBVHAccel();

  /*Bounding Box*/
  std::optional<Bounds3> getBoundingBox() const;

protected:
          /*Generating BVH Structure*/
          void buildBVHAccel();

private:
          /*Generating Triangles*/
          void generateTriangles();

public:
  // Mesh Name
  std::string meshname;
  std::vector<Vertex> vertices;
  std::vector<glm::uvec3> faces;

  // Material
  std::shared_ptr<Material> MeshMaterial;

  // Bounding Box
  Bounds3 bounding_box;

  // Shading structure
  std::shared_ptr<Shader> m_shader;

  /*BVH Acceleration Structure*/
  std::unique_ptr<BVHAcceleration> m_bvh;
  
  /*
  * Every NDC_MVP operation will generated a converted triangle stream
  * We have to use each of their memory address!
  */
  tbb::concurrent_vector< Triangle> m_converted;

  /*Generated by "void generateTriangles()" function, It's the original Triangle*/
  tbb::concurrent_vector<std::shared_ptr<Triangle>> m_triangles;
};
} // namespace SoftRasterizer

/*copy from boost*/
template <typename SizeT>
inline void hash_combine_impl(SizeT &seed, SizeT value) {
  seed ^= value + 0x9e3779b9 + (seed << 6) + (seed >> 2);
}

// Hash function for Vertex
namespace std {
template <> struct std::hash<SoftRasterizer::Vertex> {
  size_t operator()(const SoftRasterizer::Vertex &vertex) const {
    // Combine the hashes of position, color, normal, and texCoord
    size_t seed = 0;
    hash<glm::vec3> vec3Hasher;
    hash<glm::vec2> vec2Hasher;

    hash_combine_impl(seed, vec3Hasher(vertex.position));
    hash_combine_impl(seed, vec3Hasher(vertex.normal));
    hash_combine_impl(seed, vec3Hasher(vertex.color));
    hash_combine_impl(seed, vec2Hasher(vertex.texCoord));

    // Combine all hashes using bit manipulation
    return seed;
  }
};
} // namespace std

#endif // !_MESH_HPP_
