#pragma once
#ifndef _MESH_HPP_
#define _MESH_HPP_
#define GLM_ENABLE_EXPERIMENTAL // Enable experimental features
#include <bvh/BVHAcceleration.hpp>
#include <bvh/Bounds3.hpp>
#include <functional> // For std::hash
#include <glm/glm.hpp>
#include <glm/gtx/hash.hpp>
#include <memory>
#include <object/Material.hpp>
#include <object/Object.hpp>
#include <string>
#include <tbb/concurrent_vector.h>

namespace SoftRasterizer {
struct Mesh : public Object {
public:
  Mesh(const std::string &name, const SoftRasterizer::Material &_material,
       const std::vector<Vertex> &_vertices,
       const std::vector<glm::uvec3> &_faces, const Bounds3 &box);

  Mesh(const std::string &name, SoftRasterizer::Material &&_material,
       std::vector<Vertex> &&_vertices, std::vector<glm::uvec3> &&_faces,
       Bounds3 &&box);

  virtual ~Mesh();

public:
  [[nodiscard]] bool intersect(const Ray &ray) override { return true; }
  [[nodiscard]] bool intersect(const Ray &ray, float &tNear) override {
    return true;
  }
  [[nodiscard]] Intersection getIntersect(Ray &ray) override;
  [[nodiscard]] Properties getSurfaceProperties(const std::size_t faceIndex,
                                                const glm::vec3 &Point,
                                                const glm::vec3 &viewDir,
                                                const glm::vec2 &uv) override {
    return {};
  }

  [[nodiscard]] std::shared_ptr<Material> &getMaterial() override {
    return m_material;
  }
  [[nodiscard]] glm::vec3 getDiffuseColor(const glm::vec2 &uv) override {
    return glm::vec3(1.0f);
  }

  /*Compatible Consideration!*/
  [[nodiscard]] const std::vector<Vertex> &getVertices() const override {
    return vertices;
  }
  [[nodiscard]] const std::vector<glm::uvec3> &getFaces() const override {
    return faces;
  }

  [[nodiscard]] std::tuple<Intersection, float> sample() override;
  [[nodiscard]] const float getArea() override { return area; }

  void updatePosition(const glm::mat4x4 &NDC_MVP,
                      const glm::mat4x4 &Normal_M) override;

  void bindShader2Mesh(std::shared_ptr<Shader> shader) override;

  /*Rebuild BVH Structure, When Points position moved!*/
  void rebuildBVHAccel();

  void updateBounds(const Bounds3 &new_box) { bounding_box = new_box; }
  Bounds3 getBounds() override { return bounding_box; }

  /*Bounding Box*/
  std::optional<Bounds3> getBoundingBox() const;

protected:
  /*Generating BVH Structure*/
  void buildBVHAccel();

private:
  /*Generating Triangles*/
  void generateTriangles();

  /* Generate Pointers to Triangles and
   * load it to BVH Structure*/
  void preGenerateBVH();

public:
  // Mesh Name
  std::string meshname;
  std::vector<Vertex> vertices;
  std::vector<glm::uvec3> faces;

  //Mesh Area Calculation
  float area = 0.f;

  // Bounding Box
  Bounds3 bounding_box;

  /*BVH Acceleration Structure*/
  std::unique_ptr<BVHAcceleration> m_bvh;

  /* Generated by "generateTriangles()"
   * Every NDC_MVP operation Will Generate a new Vertex inside Triangle*/
  tbb::concurrent_vector<std::shared_ptr<Object>> m_triangles;
};
} // namespace SoftRasterizer

/*copy from boost*/
template <typename SizeT>
inline void hash_combine_impl(SizeT &seed, SizeT value) {
  seed ^= value + 0x9e3779b9 + (seed << 6) + (seed >> 2);
}

// Hash function for Vertex
namespace std {
template <> struct std::hash<SoftRasterizer::Vertex> {
  size_t operator()(const SoftRasterizer::Vertex &vertex) const {
    // Combine the hashes of position, color, normal, and texCoord
    size_t seed = 0;
    hash<glm::vec3> vec3Hasher;
    hash<glm::vec2> vec2Hasher;

    hash_combine_impl(seed, vec3Hasher(vertex.position));
    hash_combine_impl(seed, vec3Hasher(vertex.normal));
    hash_combine_impl(seed, vec3Hasher(vertex.color));
    hash_combine_impl(seed, vec2Hasher(vertex.texCoord));

    // Combine all hashes using bit manipulation
    return seed;
  }
};
} // namespace std

#endif // !_MESH_HPP_
